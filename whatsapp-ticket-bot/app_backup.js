// SISTEMA WHATSAPP MULTI-SESS√ÉO LIMPO - SEM SOCKET.IO COMPLEXO
require('dotenv').config();
const { OpenAI } = require('openai');
const express = require('express');
const { create } = require('@wppconnect-team/wppconnect');
const fs = require('fs');
const path = require('path');
const multer = require('multer');
const csv = require('csv-parser');
const xlsx = require('xlsx');

// Configurar OpenAI
let openai = null;
try {
  if (process.env.OPENAI_API_KEY) {
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    console.log('‚úÖ OpenAI configurada');
  } else {
    console.log('‚ö†Ô∏è OPENAI_API_KEY n√£o encontrada no .env');
  }
} catch (error) {
  console.error('‚ùå Erro ao configurar OpenAI:', error.message);
}

// Estados dos usu√°rios para controle de fluxo
const userStates = {};

// Sess√µes multi-sess√£o (simplificado)
const sessions = {
  sales: {
    client: null,
    status: 'disconnected',
    lastActivity: null
  },
  support: {
    client: null,
    status: 'disconnected', 
    lastActivity: null
  }
};

// Fun√ß√£o auxiliar para delay
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Classe para humaniza√ß√£o do bot (simplificada)
class BotHumanizer {
  constructor() {
    this.typingStates = new Map();
  }

  generateSmartDelay(messageLength) {
    const baseDelay = Math.random() * (20000 - 10000) + 10000; // 10-20 segundos
    const lengthMultiplier = Math.min(messageLength / 100, 2);
    const finalDelay = baseDelay + (lengthMultiplier * 3000);
    return Math.min(finalDelay, 30000); // M√°ximo 30 segundos
  }

  async simulateHumanResponse(client, phoneNumber, response, originalMessage) {
    try {
      const delay = this.generateSmartDelay(response.length);
      const typingDuration = Math.min(delay * 0.8, 15000);
      
      console.log(`ü§ñ Humanizando resposta para ${phoneNumber}: delay ${(delay/1000).toFixed(1)}s`);
      
      await client.sendSeen(phoneNumber);
      await this.sleep(Math.random() * 3000 + 1000);
      
      await client.startTyping(phoneNumber);
      this.typingStates.set(phoneNumber, true);
      
      const typingPauses = Math.floor(typingDuration / 5000);
      for (let i = 0; i < typingPauses; i++) {
        await this.sleep(4000 + Math.random() * 2000);
        await client.stopTyping(phoneNumber);
        await this.sleep(500 + Math.random() * 1000);
        
        if (i < typingPauses - 1) {
          await client.startTyping(phoneNumber);
        }
      }
      
      await client.startTyping(phoneNumber);
      await this.sleep(Math.random() * 3000 + 2000);
      await client.stopTyping(phoneNumber);
      this.typingStates.set(phoneNumber, false);
      
      client
        .sendText(phoneNumber, response)
        .then((result) => {
          console.log(`‚úÖ Resposta humanizada enviada para ${phoneNumber}:`, result.id);
          this.addHumanVariations(client, phoneNumber, response);
        })
        .catch((error) => {
          console.error(`‚ùå Erro ao enviar resposta humanizada:`, error);
          this.typingStates.set(phoneNumber, false);
        });
        
    } catch (error) {
      console.error('‚ùå Erro na humaniza√ß√£o:', error);
      await client.stopTyping(phoneNumber);
      this.typingStates.set(phoneNumber, false);
    }
  }

  async addHumanVariations(client, phoneNumber, originalResponse) {
    if (Math.random() < 0.2) {
      const variations = ['üòä', 'Espero ter ajudado!', 'Qualquer d√∫vida, √© s√≥ chamar üëç', 'Fico √† disposi√ß√£o!', 'üéµ'];
      const variation = variations[Math.floor(Math.random() * variations.length)];
      
      setTimeout(() => {
        client
          .sendText(phoneNumber, variation)
          .then(() => console.log(`‚ú® Varia√ß√£o humana enviada: ${variation}`))
          .catch((error) => console.error('‚ùå Erro varia√ß√£o:', error));
      }, Math.random() * 5000 + 2000);
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  isUserBeingServed(phoneNumber) {
    return this.typingStates.get(phoneNumber) || false;
  }
}

// Classe para processamento de arquivos
class FileProcessor {
  constructor() {
    this.supportedFormats = ['.csv', '.txt', '.xlsx', '.xls'];
  }

  async processFile(filePath, originalName) {
    const fileExt = path.extname(originalName).toLowerCase();
    console.log(`üìÅ Processando arquivo: ${originalName} (${fileExt})`);
    
    try {
      switch (fileExt) {
        case '.csv':
          return await this.processCSV(filePath);
        case '.txt':
          return await this.processTXT(filePath);
        case '.xlsx':
        case '.xls':
          return await this.processExcel(filePath);
        default:
          throw new Error(`Formato ${fileExt} n√£o suportado`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao processar ${originalName}:`, error);
      throw error;
    }
  }

  async processCSV(filePath) {
    return new Promise((resolve, reject) => {
      const numbers = [];
      const errors = [];
      let lineNumber = 0;

      fs.createReadStream(filePath)
        .pipe(csv({
          separator: [',', ';', '\t'],
          skipEmptyLines: true,
          skipLinesWithError: true
        }))
        .on('data', (row) => {
          lineNumber++;
          
          const possibleNumber = this.extractPhoneNumber(row);
          
          if (possibleNumber) {
            const formatted = this.formatAndValidateNumber(possibleNumber);
            if (formatted.isValid) {
              numbers.push({
                original: possibleNumber,
                formatted: formatted.number,
                name: row.nome || row.name || `Contato ${lineNumber}`,
                line: lineNumber,
                displayNumber: formatted.displayNumber
              });
            } else {
              errors.push({
                line: lineNumber,
                original: possibleNumber,
                error: formatted.error
              });
            }
          } else {
            errors.push({
              line: lineNumber,
              original: JSON.stringify(row),
              error: 'Nenhum n√∫mero de telefone encontrado'
            });
          }
        })
        .on('end', () => {
          console.log(`‚úÖ CSV processado: ${numbers.length} n√∫meros v√°lidos, ${errors.length} erros`);
          resolve({ numbers, errors, type: 'csv' });
        })
        .on('error', (error) => {
          reject(error);
        });
    });
  }

  async processTXT(filePath) {
    return new Promise((resolve, reject) => {
      fs.readFile(filePath, 'utf8', (err, data) => {
        if (err) {
          reject(err);
          return;
        }

        const lines = data.split('\n').filter(line => line.trim());
        const numbers = [];
        const errors = [];

        lines.forEach((line, index) => {
          const lineNumber = index + 1;
          const trimmedLine = line.trim();
          
          if (trimmedLine) {
            const formatted = this.formatAndValidateNumber(trimmedLine);
            if (formatted.isValid) {
              numbers.push({
                original: trimmedLine,
                formatted: formatted.number,
                name: `Contato ${lineNumber}`,
                line: lineNumber,
                displayNumber: formatted.displayNumber
              });
            } else {
              errors.push({
                line: lineNumber,
                original: trimmedLine,
                error: formatted.error
              });
            }
          }
        });

        console.log(`‚úÖ TXT processado: ${numbers.length} n√∫meros v√°lidos, ${errors.length} erros`);
        resolve({ numbers, errors, type: 'txt' });
      });
    });
  }

  async processExcel(filePath) {
    return new Promise((resolve, reject) => {
      try {
        const workbook = xlsx.readFile(filePath);
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = xlsx.utils.sheet_to_json(worksheet, { header: 1 });

        const numbers = [];
        const errors = [];

        jsonData.forEach((row, index) => {
          const lineNumber = index + 1;
          
          if (row.length > 0) {
            const possibleNumber = this.extractPhoneFromRow(row);
            
            if (possibleNumber) {
              const formatted = this.formatAndValidateNumber(possibleNumber);
              if (formatted.isValid) {
                numbers.push({
                  original: possibleNumber,
                  formatted: formatted.number,
                  name: row[1] || `Contato ${lineNumber}`,
                  line: lineNumber,
                  displayNumber: formatted.displayNumber
                });
              } else {
                errors.push({
                  line: lineNumber,
                  original: possibleNumber,
                  error: formatted.error
                });
              }
            }
          }
        });

        console.log(`‚úÖ Excel processado: ${numbers.length} n√∫meros v√°lidos, ${errors.length} erros`);
        resolve({ numbers, errors, type: 'excel' });
      } catch (error) {
        reject(error);
      }
    });
  }

  extractPhoneNumber(row) {
    const possibleFields = ['telefone', 'phone', 'numero', 'number', 'whatsapp', 'celular', 'mobile'];
    
    for (const field of possibleFields) {
      if (row[field]) {
        return String(row[field]).trim();
      }
    }
    
    const values = Object.values(row);
    for (const value of values) {
      const strValue = String(value).trim();
      if (this.looksLikePhoneNumber(strValue)) {
        return strValue;
      }
    }
    
    return null;
  }

  extractPhoneFromRow(row) {
    for (const cell of row) {
      if (cell && this.looksLikePhoneNumber(String(cell))) {
        return String(cell).trim();
      }
    }
    return null;
  }

  looksLikePhoneNumber(str) {
    const numbersOnly = str.replace(/\D/g, '');
    return numbersOnly.length >= 10 && numbersOnly.length <= 15;
  }

  formatAndValidateNumber(number) {
    let cleaned = String(number).replace(/\D/g, '');
    
    if (cleaned.length < 10) {
      return { isValid: false, error: 'N√∫mero muito curto' };
    }
    
    if (cleaned.length > 15) {
      return { isValid: false, error: 'N√∫mero muito longo' };
    }
    
    if (cleaned.length === 11 && cleaned.startsWith('11')) {
      cleaned = '55' + cleaned;
    } else if (cleaned.length === 11) {
      cleaned = '55' + cleaned;
    } else if (cleaned.length === 10) {
      cleaned = '5511' + cleaned;
    } else if (cleaned.length === 13 && cleaned.startsWith('55')) {
      // J√° tem c√≥digo do pa√≠s
    } else if (cleaned.length === 12 && !cleaned.startsWith('55')) {
      cleaned = '55' + cleaned;
    }
    
    const whatsappNumber = cleaned + '@c.us';
    
    return {
      isValid: true,
      number: whatsappNumber,
      displayNumber: this.formatDisplayNumber(cleaned),
      error: null
    };
  }

  formatDisplayNumber(number) {
    if (number.length === 13 && number.startsWith('55')) {
      const ddd = number.substring(2, 4);
      const prefix = number.substring(4, 9);
      const suffix = number.substring(9);
      return `+55 (${ddd}) ${prefix}-${suffix}`;
    }
    return number;
  }
}

// Instanciar classes globalmente
const botHumanizer = new BotHumanizer();
const fileProcessor = new FileProcessor();

// Fun√ß√£o para criar sess√£o de vendas
async function createSalesSession() {
  console.log('üõí Iniciando sess√£o de VENDAS...');
  
  try {
    // Caminho expl√≠cito para o Chrome instalado pelo Puppeteer
    const chromePath = path.join(__dirname, 'chrome', 'win64-141.0.7351.0', 'chrome-win64', 'chrome.exe');
    
    const client = await create({
      session: 'sales',
      catchQR: (base64Qr, asciiQR) => {
        console.log('üì± QR Code VENDAS gerado');
        sessions.sales.status = 'qr_ready';
        
        const qrPath = path.join(__dirname, 'public', 'qr-sales.png');
        const base64Data = base64Qr.replace(/^data:image\/png;base64,/, '');
        fs.writeFileSync(qrPath, base64Data, 'base64');
        console.log('‚úÖ QR Code VENDAS salvo: qr-sales.png');
      },
      statusFind: (statusSession, session) => {
        console.log(`üõí VENDAS - Estado: ${statusSession}`);
        sessions.sales.status = statusSession.toLowerCase();
        
        if (statusSession === 'CONNECTED') {
          console.log('‚úÖ Bot VENDAS conectado com sucesso!');
          sessions.sales.status = 'connected';
        }
      },
      headless: true,
      devtools: false,
      debug: false,
      logQR: false,
      autoClose: 60000,
      disableSpins: true,
      puppeteerOptions: {
        headless: true,
        executablePath: fs.existsSync(chromePath) ? chromePath : undefined,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--no-first-run',
          '--no-zygote',
          '--disable-gpu',
          '--disable-web-security',
          '--disable-features=VizDisplayCompositor'
        ]
      }
    });

    // Manipulador de mensagens para vendas
    client.onMessage(async (message) => {
      try {
        if (message.isGroupMsg || message.from === 'status@broadcast') return;
        sessions.sales.lastActivity = new Date();
        console.log(`üí∞ VENDAS - ${message.from}: ${message.body}`);
        
        if (message.body === 'Hello') {
          await client.sendText(message.from, 'üèÜ Ol√°! Bem-vindo √† ROYAL ‚Äì A NOITE √â SUA, O REINADO √â NOSSO!');
          setTimeout(async () => {
            await client.sendText(message.from, 'üî• MC DANIEL ‚Äì O FALC√ÉO vai comandar o palco! \n\nSe √© luxo e exclusividade que voc√™ procura‚Ä¶ Aqui √© o seu lugar!\n\nDigite *EVENTOS* para ver todas as op√ß√µes de ingressos e camarotes! üé´‚ú®');
          }, 1000);
        } else {
          await handleSalesMessage(client, message);
        }
      } catch (error) {
        console.error('‚ùå VENDAS - Erro no handler:', error);
      }
    });

    sessions.sales.client = client;
    return client;

  } catch (error) {
    console.error('‚ùå Erro ao criar sess√£o de vendas:', error);
    throw error;
  }
}

// Fun√ß√£o para criar sess√£o de suporte
async function createSupportSession() {
  console.log('üõü Iniciando sess√£o de SUPORTE...');
  
  try {
    // Caminho expl√≠cito para o Chrome instalado pelo Puppeteer
    const chromePath = path.join(__dirname, 'chrome', 'win64-141.0.7351.0', 'chrome-win64', 'chrome.exe');
    
    const client = await create({
      session: 'support',
      catchQR: (base64Qr, asciiQR) => {
        console.log('üì± QR Code SUPORTE gerado');
        sessions.support.status = 'qr_ready';
        
        const qrPath = path.join(__dirname, 'public', 'qr-support.png');
        const base64Data = base64Qr.replace(/^data:image\/png;base64,/, '');
        fs.writeFileSync(qrPath, base64Data, 'base64');
        console.log('‚úÖ QR Code SUPORTE salvo: qr-support.png');
      },
      statusFind: (statusSession, session) => {
        console.log(`üõü SUPORTE - Estado: ${statusSession}`);
        sessions.support.status = statusSession.toLowerCase();
        
        if (statusSession === 'CONNECTED') {
          console.log('‚úÖ Bot SUPORTE conectado com sucesso!');
          sessions.support.status = 'connected';
        }
      },
      headless: true,
      devtools: false,
      debug: false,
      logQR: false,
      autoClose: 60000,
      disableSpins: true,
      puppeteerOptions: {
        headless: true,
        executablePath: fs.existsSync(chromePath) ? chromePath : undefined,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--no-first-run',
          '--no-zygote',
          '--disable-gpu',
          '--disable-web-security',
          '--disable-features=VizDisplayCompositor'
        ]
      }
    });

    // Manipulador de mensagens para suporte
    client.onMessage(async (message) => {
      try {
        if (message.isGroupMsg || message.from === 'status@broadcast') return;
        sessions.support.lastActivity = new Date();
        console.log(`üõü SUPORTE - ${message.from}: ${message.body}`);
        
        if (message.body === 'Hello') {
          client.sendText(message.from, 'üõü Ol√°! Este √© o suporte da Casa de Show. Como posso ajudar?')
            .then((result) => console.log('‚úÖ SUPORTE - Resposta enviada:', result.id))
            .catch((erro) => console.error('‚ùå SUPORTE - Erro ao enviar:', erro));
        } else {
          await handleSupportMessage(client, message);
        }
      } catch (error) {
        console.error('‚ùå SUPORTE - Erro no handler:', error);
      }
    });

    sessions.support.client = client;
    return client;

  } catch (error) {
    console.error('‚ùå Erro ao criar sess√£o de suporte:', error);
    throw error;
  }
}

// Fun√ß√µes de mensagem humanizadas
async function handleSalesMessage(client, message) {
  const userId = message.from;
  const userMessage = (message.body || '').toLowerCase();
  
  if (botHumanizer.isUserBeingServed(userId)) {
    console.log(`‚è≥ ${userId} j√° est√° sendo atendido, ignorando mensagem`);
    return;
  }
  
  // Verificar se a pergunta √© sobre localiza√ß√£o ANTES de qualquer processamento
  console.log(`üîç Verificando localiza√ß√£o para: "${userMessage}"`);
  if (userMessage.includes('localiza√ß√£o') || userMessage.includes('localizacao') || 
      userMessage.includes('endere√ßo') || userMessage.includes('endereco') || 
      userMessage.includes('onde fica') || userMessage.includes('onde √©') || 
      userMessage.includes('local') || userMessage.includes('lugar') || 
      userMessage.includes('como chegar') || userMessage.includes('mapa') || 
      userMessage.includes('google maps') || userMessage.includes('maps') ||
      userMessage.includes('rua') || userMessage.includes('avenida') || 
      userMessage.includes('bairro') || userMessage.includes('cidade')) {
    
    console.log(`üìç LOCALIZA√á√ÉO DETECTADA! Enviando resposta...`);
    const response = `üìç *LOCALIZA√á√ÉO DA ROYAL*

üè¢ **Endere√ßo:**
Av. Arquiteto Rubens Gil de Camillo, 20
Ch√°cara Cachoeira
Campo Grande - MS
CEP: 79040-090

üó∫Ô∏è **Localiza√ß√£o no Mapa:**
üëâ https://maps.app.goo.gl/kS7oyF2kXVQZtp9C7

üöó *F√°cil acesso!*
üéØ *Localiza√ß√£o privilegiada em Campo Grande!*

Para mais informa√ß√µes sobre o evento, digite *EVENTOS*!`;
    
    await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
    console.log(`‚úÖ Resposta de localiza√ß√£o enviada para ${userId}`);
    return;
  }

  // Verificar se a pergunta √© sobre camarote ou bistro
  if (userMessage.includes('camarote') || userMessage.includes('camarotes') || 
      userMessage.includes('bistro') || userMessage.includes('bistros') || 
      userMessage.includes('bistr√¥') || userMessage.includes('bistr√¥s')) {
    
    const response = `üë§ *ATENDIMENTO PERSONALIZADO*

Para um atendimento completo e personalizado, fale diretamente com nossa equipe:

üì≤ *WhatsApp Atendimento:*
üëâ https://wa.me/556792941631

Nossa equipe est√° dispon√≠vel para:
‚úÖ Informa√ß√µes sobre eventos
‚úÖ D√∫vidas sobre ingressos
‚úÖ Suporte especializado
‚úÖ Atendimento VIP

‚è∞ *Hor√°rio de atendimento:* 
Segunda a Domingo - 10h √†s 22h`;
    
    await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
    return;
  }

  if (!userStates[userId]) {
    userStates[userId] = {
      step: 'inicio',
      cart: [],
      total: 0,
      session: 'sales'
    };
  }
  
  const userState = userStates[userId];
  
  try {
    let response;
    let shouldHumanize = true;
    
    switch (userState.step) {
      case 'inicio':
        if (userMessage.includes('oi') || userMessage.includes('ola') || userMessage.includes('hello')) {
          response = `üèÜ *Bem-vindo √† ROYAL ‚Äì A NOITE √â SUA, O REINADO √â NOSSO!*

üî• Prepare-se para uma noite LEND√ÅRIA!
üé§ MC DANIEL ‚Äì O FALC√ÉO vai comandar o palco com os hits que t√£o explodindo em todo o Brasil!

üõí *MENU DE OP√á√ïES:*
1Ô∏è‚É£ Ver *EVENTOS* completos
2Ô∏è‚É£ *RESERVAR* bistr√¥s e camarotes
3Ô∏è‚É£ Falar com *ATENDIMENTO*

üí∞ *Formas de pagamento:* PIX, Cart√£o
üöö *Entrega:* Digital (WhatsApp) ou Retirada

Digite o *n√∫mero* da op√ß√£o desejada!`;
          userState.step = 'menu';
        } else {
          // Qualquer outra mensagem tamb√©m mostra o menu
          response = `üèÜ *Bem-vindo √† ROYAL ‚Äì A NOITE √â SUA, O REINADO √â NOSSO!*

üî• Prepare-se para uma noite LEND√ÅRIA!
üé§ MC DANIEL ‚Äì O FALC√ÉO vai comandar o palco com os hits que t√£o explodindo em todo o Brasil!

üõí *MENU DE OP√á√ïES:*
1Ô∏è‚É£ Ver *EVENTOS* completos
2Ô∏è‚É£ *RESERVAR* bistr√¥s e camarotes
3Ô∏è‚É£ Falar com *ATENDIMENTO*

üí∞ *Formas de pagamento:* PIX, Cart√£o
üöö *Entrega:* Digital (WhatsApp) ou Retirada

Digite o *n√∫mero* da op√ß√£o desejada!`;
          userState.step = 'menu';
        }
        break;
        
      case 'menu':
        if (userMessage.includes('1') || userMessage.includes('eventos') || userMessage.includes('evento') || userMessage.includes('cardapio') || userMessage.includes('card√°pio')) {
          response = await generateCatalogResponse();
          userState.step = 'catalogo';
        } else if (userMessage.includes('2') || userMessage.includes('reservar') || userMessage.includes('reserva') || userMessage.includes('bistro') || userMessage.includes('camarote')) {
          response = `üçæ *RESERVAS BISTR√îS E CAMAROTES*

Para fazer sua reserva e garantir o melhor lugar na casa, entre em contato diretamente com nossa equipe especializada:

üì≤ *WhatsApp para Reservas:*
üëâ https://wa.me/556792941631

Nossa equipe est√° pronta para:
‚úÖ Tirar todas suas d√∫vidas
‚úÖ Fazer sua reserva personalizada  
‚úÖ Oferecer as melhores condi√ß√µes
‚úÖ Garantir sua mesa/camarote

üí∞ *Condi√ß√µes especiais dispon√≠veis!*
üèÜ *Atendimento VIP exclusivo!*`;
          shouldHumanize = false;
        } else if (userMessage.includes('3') || userMessage.includes('atendimento')) {
          response = `üë§ *ATENDIMENTO PERSONALIZADO*

Para um atendimento completo e personalizado, fale diretamente com nossa equipe:

üì≤ *WhatsApp Atendimento:*
üëâ https://wa.me/556792941631

Nossa equipe est√° dispon√≠vel para:
‚úÖ Informa√ß√µes sobre eventos
‚úÖ D√∫vidas sobre ingressos
‚úÖ Suporte especializado
‚úÖ Atendimento VIP

‚è∞ *Hor√°rio de atendimento:* 
Segunda a Domingo - 10h √†s 22h`;
          shouldHumanize = false;
        } else {
          // Op√ß√£o inv√°lida - mostra o menu novamente
          response = `‚ùå *Op√ß√£o inv√°lida!*

üõí *MENU DE OP√á√ïES:*
1Ô∏è‚É£ Ver *EVENTOS* completos
2Ô∏è‚É£ *RESERVAR* bistr√¥s e camarotes
3Ô∏è‚É£ Falar com *ATENDIMENTO*

Digite o *n√∫mero* da op√ß√£o desejada (1, 2 ou 3)!`;
          // Mant√©m no step 'menu' para continuar aguardando op√ß√£o v√°lida
        }
        break;
        
      case 'catalogo':
        response = await handleCatalogSelection(userMessage);
        break;
        
      default:
        response = await generateCatalogResponse();
        userState.step = 'catalogo';
        break;
    }
    
    userStates[userId] = userState;
    
    if (shouldHumanize) {
      await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
    } else {
      await client.sendSeen(userId);
      await client.startTyping(userId);
      await sleep(1000 + Math.random() * 2000);
      await client.stopTyping(userId);
      
      client
        .sendText(userId, response)
        .then((result) => console.log('‚úÖ Resposta r√°pida enviada:', result.id))
        .catch((error) => console.error('‚ùå Erro resposta r√°pida:', error));
    }
    
  } catch (error) {
    console.error('‚ùå Erro no handleSalesMessage:', error);
    await client.stopTyping(userId);
    await client.sendText(userId, '‚ùå Ops! Ocorreu um erro. Digite *menu* para voltar ao in√≠cio.');
  }
}

async function handleSupportMessage(client, message) {
  const userId = message.from;
  const userMessage = (message.body || '').toLowerCase();
  
  if (botHumanizer.isUserBeingServed(userId)) {
    console.log(`‚è≥ ${userId} j√° est√° sendo atendido, ignorando mensagem`);
    return;
  }
  
  try {
    let response;
    
    // Verificar se a pergunta √© sobre localiza√ß√£o
    if (userMessage.includes('localiza√ß√£o') || userMessage.includes('localizacao') || 
        userMessage.includes('endere√ßo') || userMessage.includes('endereco') || 
        userMessage.includes('onde fica') || userMessage.includes('onde √©') || 
        userMessage.includes('local') || userMessage.includes('lugar') || 
        userMessage.includes('como chegar') || userMessage.includes('mapa') || 
        userMessage.includes('google maps') || userMessage.includes('maps') ||
        userMessage.includes('rua') || userMessage.includes('avenida') || 
        userMessage.includes('bairro') || userMessage.includes('cidade')) {
      
      response = `üìç *LOCALIZA√á√ÉO DA ROYAL*

üè¢ **Endere√ßo:**
Av. Arquiteto Rubens Gil de Camillo, 20
Ch√°cara Cachoeira
Campo Grande - MS
CEP: 79040-090

üó∫Ô∏è **Localiza√ß√£o no Mapa:**
üëâ https://maps.app.goo.gl/kS7oyF2kXVQZtp9C7

üöó *F√°cil acesso!*
üéØ *Localiza√ß√£o privilegiada em Campo Grande!*

üõü Para mais informa√ß√µes, acesse:
üëâ https://links.totalingressos.com/mc-daniel-na-royal.html`;
      
      await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
      return;
    }

    // Verificar se a pergunta √© sobre camarote ou bistro
    if (userMessage.includes('camarote') || userMessage.includes('camarotes') || 
        userMessage.includes('bistro') || userMessage.includes('bistros') || 
        userMessage.includes('bistr√¥') || userMessage.includes('bistr√¥s')) {
      
      response = `üë§ *ATENDIMENTO PERSONALIZADO*

Para um atendimento completo e personalizado, fale diretamente com nossa equipe:

üì≤ *WhatsApp Atendimento:*
üëâ https://wa.me/556792941631

Nossa equipe est√° dispon√≠vel para:
‚úÖ Informa√ß√µes sobre eventos
‚úÖ D√∫vidas sobre ingressos
‚úÖ Suporte especializado
‚úÖ Atendimento VIP

‚è∞ *Hor√°rio de atendimento:* 
Segunda a Domingo - 10h √†s 22h`;
      
      await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
      return;
    }
    
    if (!openai) {
      response = 'üõü Ol√°! Sou o suporte da Royal. Como posso ajudar?\n\nPara informa√ß√µes sobre ingressos, acesse:\nüëâ https://links.totalingressos.com/mc-daniel-na-royal.html';
      await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
      return;
    }
    
    const aiResponse = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "Voc√™ √© um assistente de suporte da casa de shows ROYAL. O evento √© com MC DANIEL. Seja prestativo e direto. Sempre indique o link oficial: https://links.totalingressos.com/mc-daniel-na-royal.html"
        },
        {
          role: "user", 
          content: userMessage
        }
      ],
      max_tokens: 300,
      temperature: 0.7
    });
    
    response = `üõü ${aiResponse.choices[0].message.content}`;
    await botHumanizer.simulateHumanResponse(client, userId, response, userMessage);
    
  } catch (error) {
    console.error('‚ùå Erro OpenAI:', error);
    const fallbackResponse = 'üõü Ol√°! Sou o suporte da Royal. Para informa√ß√µes sobre ingressos, acesse:\nüëâ https://links.totalingressos.com/mc-daniel-na-royal.html';
    await botHumanizer.simulateHumanResponse(client, userId, fallbackResponse, userMessage);
  }
}

// Fun√ß√µes auxiliares para gerar respostas
async function generateCatalogResponse() {
  return `üèÜ *ROYAL ‚Äì EVENTOS DISPON√çVEIS*

üöó *CAMAROTES PREMIUM ‚Äì Entre no universo dos milion√°rios*

üèéÔ∏è *McLaren, Ferrari, Lamborghini, Porsche*
üí∞ R$ 6.000 | üí≥ Consumo: R$ 2.500 | üéü 4 entradas inclu√≠das

üöó *Porsche*
üí∞ R$ 5.000 | üí≥ Consumo: R$ 2.000 | üéü 4 entradas inclu√≠das

üöô *Bugatti, Rolls Royce, Jaguar, Mercedes-Benz*
üí∞ R$ 4.000 | üí≥ Consumo: R$ 1.500 | üéü 4 entradas inclu√≠das

üèÅ *Royal, BMW, Aston Martin, Land Rover*
üí∞ R$ 4.000 | üí≥ Consumo: R$ 1.500 | üéü 4 entradas inclu√≠das

‚∏ª

üçæ *BISTR√îS ROYAL ‚Äì Assista o show de pertinho*

ü•á *1¬™ fileira* ‚Äì R$ 700 | Consumo: R$ 300 | üéü 2 entradas inclu√≠das
ü•à *2¬™ fileira* ‚Äì R$ 600 | Consumo: R$ 300 | üéü 2 entradas inclu√≠das  
ü•â *3¬™ fileira* ‚Äì R$ 500 | Consumo: R$ 250 | üéü 2 entradas inclu√≠das
4Ô∏è‚É£ *4¬™ fileira* ‚Äì R$ 400 | Consumo: R$ 200 | üéü 2 entradas inclu√≠das

‚∏ª

üéü *Ingressos Individuais*
üé™ *Pista* ‚Äì R$ 60

‚∏ª

üí• *LINK OFICIAL PARA COMPRA:*
üëâ https://links.totalingressos.com/mc-daniel-na-royal.html

üí∏ *Pix direto = reserva confirmada!*
‚ö†Ô∏è Sem estorno em caso de cancelamento. Evento +18.`;
}

async function generatePromotionsResponse() {
  return `üî• *ROYAL ‚Äì PROMO√á√ïES ESPECIAIS*

üí∏ *PIX DIRETO = RESERVA CONFIRMADA!*
‚ö° Pagamento instant√¢neo e lugar garantido

üèÜ *CAMAROTES ESGOTANDO R√ÅPIDO!*
üöó McLaren, Ferrari, Lamborghini limitados
üçæ Bistr√¥s com vista privilegiada

üé´ *LINK OFICIAL PARA COMPRA:*
üëâ https://links.totalingressos.com/mc-daniel-na-royal.html

‚ö†Ô∏è *IMPORTANTE:*
‚Ä¢ Sem estorno em caso de cancelamento
‚Ä¢ Evento +18 anos
‚Ä¢ Camarotes e Bistr√¥s esgotam primeiro

üì≤ *Chama no WhatsApp para garantir:*
Digite *EVENTOS* para ver todas as op√ß√µes!`;
}

async function handleCatalogSelection(userMessage) {
  if (userMessage.includes('link') || userMessage.includes('comprar') || userMessage.includes('site')) {
    return `üé´ *LINK OFICIAL PARA COMPRA:*
üëâ https://links.totalingressos.com/mc-daniel-na-royal.html

üí∏ Pix direto = reserva confirmada!
‚ö†Ô∏è Sem estorno em caso de cancelamento. Evento +18.

Para mais informa√ß√µes, digite *EVENTOS* ou entre em contato conosco!`;
  } else {
    return `Para comprar ingressos acesse:
üëâ https://links.totalingressos.com/mc-daniel-na-royal.html

Ou digite *EVENTOS* para ver todas as op√ß√µes novamente!`;
  }
}

// Fun√ß√£o para envio de campanha humanizada (simplificada)
async function sendHumanizedCampaign(client, numbers, message, sessionName) {
  const results = { sent: 0, failed: 0, errors: [] };
  
  console.log(`üì¢ Iniciando campanha humanizada ${sessionName} para ${numbers.length} n√∫meros...`);
  
  for (let i = 0; i < numbers.length; i++) {
    try {
      const number = numbers[i];
      const formattedNumber = number.includes('@c.us') ? number : number + '@c.us';
      
      console.log(`üì± ${sessionName} - Enviando ${i + 1}/${numbers.length} para ${number}...`);
      
      await client.sendSeen(formattedNumber);
      await sleep(Math.random() * 3000 + 2000);
      
      await client.startTyping(formattedNumber);
      await sleep(Math.random() * 5000 + 3000);
      await client.stopTyping(formattedNumber);
      
      await client.sendText(formattedNumber, message);
      
      results.sent++;
      console.log(`‚úÖ ${sessionName} - Enviado humanizado para ${number}`);
      
      if (i < numbers.length - 1) {
        const campaignDelay = Math.random() * (5000 - 1000) + 1000; // 1-5 segundos
        console.log(`‚è≥ Aguardando ${(campaignDelay/1000).toFixed(1)}s antes da pr√≥xima mensagem...`);
        await sleep(campaignDelay);
      }
      
    } catch (error) {
      results.failed++;
      results.errors.push({ number: numbers[i], error: error.message });
      console.error(`‚ùå ${sessionName} - Erro para ${numbers[i]}:`, error.message);
    }
  }
  
  console.log(`üìä Campanha humanizada ${sessionName} finalizada: ${results.sent} enviadas, ${results.failed} falhas`);
  return results;
}

// Interface web simplificada
function startWebInterface() {
  const app = express();
  
  app.use(express.static('public'));
  app.use(express.json());
  
  // Configurar multer para upload
  const storage = multer.diskStorage({
    destination: (req, file, cb) => {
      const uploadDir = 'uploads/';
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      const timestamp = Date.now();
      const originalName = file.originalname.replace(/[^a-zA-Z0-9.]/g, '_');
      cb(null, `${timestamp}_${originalName}`);
    }
  });

  const upload = multer({ 
    storage: storage,
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (req, file, cb) => {
      const allowedTypes = ['.csv', '.txt', '.xlsx', '.xls'];
      const fileExt = path.extname(file.originalname).toLowerCase();
      
      if (allowedTypes.includes(fileExt)) {
        cb(null, true);
      } else {
        cb(new Error('Tipo de arquivo n√£o suportado. Use CSV, TXT ou Excel.'));
      }
    }
  });
  
  // Rota principal
  app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
  });
  
  // API para iniciar sess√µes
  app.post('/api/sessions/:sessionName/start', async (req, res) => {
    try {
      const { sessionName } = req.params;
      
      if (sessionName === 'sales') {
        await createSalesSession();
      } else if (sessionName === 'support') {
        await createSupportSession();
      } else {
        return res.status(400).json({ 
          success: false, 
          message: 'Sess√£o inv√°lida' 
        });
      }
      
      res.json({ 
        success: true, 
        message: `Sess√£o ${sessionName} iniciada` 
      });
      
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  });
  
  // API para parar sess√µes
  app.post('/api/sessions/:sessionName/stop', async (req, res) => {
    try {
      const { sessionName } = req.params;
      
      if (sessions[sessionName]?.client) {
        await sessions[sessionName].client.close();
        sessions[sessionName] = {
          client: null,
          status: 'disconnected',
          lastActivity: null
        };
      }
      
      res.json({ 
        success: true, 
        message: `Sess√£o ${sessionName} parada` 
      });
      
    } catch (error) {
      res.status(500).json({ 
        success: false, 
        message: error.message 
      });
    }
  });

  // Upload de arquivo
  app.post('/api/upload/numbers', upload.single('numbersFile'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          message: 'Nenhum arquivo foi enviado'
        });
      }

      const fileInfo = {
        id: Date.now(),
        originalName: req.file.originalname,
        filename: req.file.filename,
        path: req.file.path,
        size: req.file.size,
        uploadedAt: new Date(),
        processed: false
      };

      global.uploadedFiles = global.uploadedFiles || new Map();
      global.uploadedFiles.set(fileInfo.id, fileInfo);

      res.json({
        success: true,
        message: 'Arquivo enviado com sucesso! Clique em "Processar" para extrair os n√∫meros.',
        fileInfo: {
          id: fileInfo.id,
          name: fileInfo.originalName,
          size: `${(fileInfo.size / 1024).toFixed(1)} KB`,
          type: path.extname(fileInfo.originalName)
        }
      });

    } catch (error) {
      console.error('‚ùå Erro no upload:', error);
      res.status(500).json({
        success: false,
        message: 'Erro ao fazer upload: ' + error.message
      });
    }
  });

  // Processar arquivo carregado
  app.post('/api/upload/process/:fileId', async (req, res) => {
    try {
      const fileId = parseInt(req.params.fileId);
      const fileInfo = global.uploadedFiles?.get(fileId);

      if (!fileInfo) {
        return res.status(404).json({
          success: false,
          message: 'Arquivo n√£o encontrado'
        });
      }

      console.log(`üîÑ Processando arquivo: ${fileInfo.originalName}`);

      const result = await fileProcessor.processFile(fileInfo.path, fileInfo.originalName);
      
      fileInfo.processed = true;
      fileInfo.processedAt = new Date();
      fileInfo.result = result;

      global.lastProcessedNumbers = result.numbers.map(contact => ({
        original: contact.original,
        formatted: contact.formatted,
        name: contact.name,
        line: contact.line,
        displayNumber: contact.displayNumber || contact.original
      }));

      const responseData = {
        totalLines: result.numbers.length + result.errors.length,
        validNumbers: result.numbers.length,
        errors: result.errors.length,
        numbers: result.numbers.slice(0, 50).map(contact => ({
          original: contact.original,
          formatted: contact.formatted,
          name: contact.name,
          line: contact.line,
          displayNumber: contact.displayNumber || contact.original
        })),
        hasMore: result.numbers.length > 50,
        errorSample: result.errors.slice(0, 10).map(error => ({
          line: error.line,
          original: String(error.original).substring(0, 100),
          error: String(error.error).substring(0, 100)
        }))
      };

      res.json({
        success: true,
        message: `Arquivo processado com sucesso!`,
        data: responseData
      });

    } catch (error) {
      console.error('‚ùå Erro ao processar arquivo:', error);
      res.status(500).json({
        success: false,
        message: 'Erro ao processar arquivo: ' + error.message
      });
    }
  });

  // Envio de campanhas
  app.post('/api/campaigns/send', async (req, res) => {
    try {
      const { sessionName = 'sales', message, numbers } = req.body;
      const client = sessions[sessionName]?.client;
      
      if (!client) {
        return res.status(400).json({ 
          success: false, 
          message: `Sess√£o ${sessionName} n√£o conectada` 
        });
      }
      
      if (!message || !message.trim()) {
        return res.status(400).json({
          success: false,
          message: 'Mensagem n√£o pode estar vazia'
        });
      }
      
      let numbersToSend = [];
      
      if (numbers && numbers.length > 0) {
        numbersToSend = numbers;
      } else if (global.lastProcessedNumbers && global.lastProcessedNumbers.length > 0) {
        numbersToSend = global.lastProcessedNumbers.map(contact => contact.formatted);
      } else {
        return res.status(400).json({
          success: false,
          message: 'Nenhum n√∫mero v√°lido encontrado para envio'
        });
      }
      
      if (!numbersToSend || numbersToSend.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Nenhum n√∫mero v√°lido encontrado para envio'
        });
      }
      
      console.log(`üì¢ Iniciando campanha humanizada ${sessionName} para ${numbersToSend.length} n√∫meros...`);
      
      sendHumanizedCampaign(client, numbersToSend, message, sessionName)
        .then(results => {
          console.log(`üìä Campanha ${sessionName} finalizada: ${results.sent} enviadas, ${results.failed} falhas`);
        })
        .catch(error => {
          console.error(`‚ùå Erro na campanha ${sessionName}:`, error);
        });
      
      res.json({
        success: true,
        message: `Campanha humanizada iniciada via ${sessionName}!`,
        results: {
          total: numbersToSend.length,
          status: 'iniciada'
        }
      });
      
    } catch (error) {
      console.error('‚ùå Erro na API de campanha:', error);
      res.status(500).json({
        success: false,
        message: 'Erro ao enviar campanha: ' + error.message
      });
    }
  });
  
  const PORT = process.env.PORT || 3005;
  app.listen(PORT, () => {
    console.log(`üåê Interface web multi-sess√£o: http://localhost:${PORT}`);
  });
}

// Fun√ß√£o principal
async function initializeSystem() {
  console.log('üöÄ Iniciando sistema multi-sess√£o WhatsApp LIMPO...');
  
  const dirs = ['uploads', 'logs', 'tokens'];
  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  });
  
  startWebInterface();
  
  setTimeout(() => {
    console.log('');
    console.log('üåê Sistema LIMPO pronto!');
    console.log('üì± Acesse: http://localhost:' + (process.env.PORT || 3005));
    console.log('üõí Use a interface para conectar as sess√µes');
    console.log('');
  }, 3000);
}

// Inicializar vari√°veis globais
global.lastProcessedNumbers = [];
global.uploadedFiles = new Map();

// EXECUTAR
initializeSystem().catch(console.error);
